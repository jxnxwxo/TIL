7/7 (p.930)

<프로젝트> JS로 id, pw 검수하는것도 필요, 서버측에서 검수하는것도 필요! (중간에 해커가 위변조, 유실 시킬수 있기 때문에)

어떤방법이든 request.getparameter로 바껴서 수행

세팅할땐 셋, 데이터얻을땐 겟 -> Model -> addAttribute -> request.setAttribute



서블릿은 다이나믹 웹 프로젝트 -> 웹컨트롤러에 서블릿 생성 ->  별명 /main 지어주고 -> service 생성하고 ->

protected void myService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String id = request.getParameter("id");
		String pw = request.getParameter("pw");
		

requestdispatcher 다른곳으로 넘김(포워딩, dmz는 못들어감, index로 얘기해줘야)

		RequestDispatcher disp=request.getRequestDispatcher("/WEB-INF/views/test/main.jsp");
		request.setAttribute("id", id);
		request.setAttribute("pw", pw);
		disp.forward(request, response);

서블릿: form action="main"
메인컨트롤러: form action="test/main1.do"

WEB-INF는 브라우저에서 접근이 안됨 (dmz) 그래서 WEB-INF는 보안이 좋다
/WEB-INF/views/test/main.jsp 대신 main.jsp



​		MemberService memberService = new MemberService();	//나쁜코드

한번만해도좋을 위치로 -> init메서드 만듬

<<<표26-2>>> (p.921)

#action-servlet.xml에서
<context:component-scan base-package="web"></context:component-scan> 가 스캔하면서

@Autowired //오토와이어드 = new 만들어줌 + <<<<스프링의 환상>>>>
	MemberService memberService; //= new MemberService();

!!! 쓰려면 #mainController public class 위에 @Controller라고 알려줘야함
!!! 쓰려면 #memberService public class 위에 @Service라고 알려줘야함
!!! 쓰려면 #memberDAO  public class 위에 @Repository라고 알려줘야함

<<<<Servlet.jsp을 알아야함>>>>

Autowired 쓰면 new는 쓰지말자 (심지어 autowired는 성능이 더 안좋음)

스프링의 @controller @requestmapping 의미를 알자



--------- 27장 ----------

SpringBoot (Maven/Gradle)

도구설치하고 환경변수는 bin 보이는 곳까지



현업 -> Spring Legacy Project (기존에 있었던)

at pom.xml
그룹아이디 com.jes
아티팩티드 myapp
배포형태 war

src/main/resources - 마이바티스같은거 연동할때

소스코드는 주로 위쪽, 아래쪽에서는 주로 webapp



web.xml
url pattern / > 뜻 -> 아무것도 얘기안되있으면 디스패처로 가라 ->컨트롤러로가라
다른걸로 바꾸면 webapp에서 찾아라

*.jes로 바꿨으면 컨트롤러가서 value= "/home.jes" 라고해줘야함



ㅡㅡㅡㅡㅡ카페ㅡㅡㅡㅡㅡ

#my.js 한번만 쓸 값(바꾸지않을 값은)  var보다 const 가 좋음

@ResponseBody = printwriter~~ ???

마이바티스에서는 SqlSession을 가져와야함

xml에 name space, xml에 id => mapper.member.memberInsert



#my.js id:id -> id, pw:pw -> pw 비구조화 할당

index.html은 바디까지 읽고 로드가됨



ready 문서가 로드되었을때, .click은 버튼을 눌렀을때

​			var login=$.cookie('logined');
​			$("#msgDiv").html(login);

를 바로 my.js에  로그인 쿠키 있는지 보고 html 위치에 넣어줘

json을 써야 핸들링 하기 쉬움 그냥 html하면 어려움 -> json 라이브러리 필요

세션처리 -> 웹의 50%



홈컨트롤러 = 자바

톰캣은 자바만 이해, 자바스크립트 이해 못함

제이슨 = 자바 / `자바` 는 `자바스크립트`가 아님





컨트롤러, 모델 이런게 자바 -> JVM이 돌려줌

jsp(뷰의역할, 하지만 서블릿으로 돌아감, JVM으로 돌아감)

뷰페이지들(정적파일들) -> html/css/js 이런건 JVM으로 해석하지도 않고 처리하지도 않음, 톰캣이 일하는게 아니라 `웹서버`가 일하는거임!

톰캣은 `웹 컨테이너` 자바를 서비스 해주는애

웹서버는 정적인 파일들만 처리해주는것 .html .css .js
웹서버가 아무처리안하고 그냥 돌려주는것
php, asp(CGI) 뭘 쓰든간에 html/css/js를 처리해주는 애들이 아님.
http는 정적인페이지를 요청을 받으면 웹서버가 아무처리안하고 그냥 주는것

이걸 해석하는게 웹 브라우저임(html해석기, css해석기, js해석기)

웹브라우저(크롬, IE) 낮은버전을 깔면 네이버같은 페이지 index.html html, css다 다운 받아지는데 해석을 못함 (가끔씩 브라우저에 텍스트만 나오는경우 해석이 안되는경우임) -> 정적인 파일을 해석하는건 브라우저의 역할임

컨트롤러에서 응답을 뭘하든간에 해석은 브라우저에서 함.

JSON데이터는 응답하는데 js는 응답안합니까?
JSON {"K","V"}형태지만 js는 Object형태여야지만 js해석기가 일을함 (텍스트가 아니라)

Json String 형태 객체 자체들어가는게 아니라 객체가 가르키는 {"K":"V"}같은 텍스트가 아웃버퍼로 들어가는것 js Object로 바꿔서 쓰는게 parse

js Object로 바꿔서 자기 메모리에 올려서 쓸거라서, 텍스트를 객체로 만들어서 (파싱해서)

JVM 에서 js Object는 취급도 못함



